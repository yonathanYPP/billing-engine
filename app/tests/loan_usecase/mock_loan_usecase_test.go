// Code generated by MockGen. DO NOT EDIT.
// Source: app/usecases/loan_usecase.go

// Package mocks is a generated GoMock package.
package mocks

import (
	models "billing-engine/app/models"
	reflect "reflect"
	"testing"

	gomock "github.com/golang/mock/gomock"
)

func TestNewMockLoanUsecase(t *testing.T) {
	type args struct {
		ctrl *gomock.Controller
	}
	tests := []struct {
		name string
		args args
		want *MockLoanUsecase
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewMockLoanUsecase(tt.args.ctrl); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewMockLoanUsecase() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecase_EXPECT(t *testing.T) {
	type fields struct {
		ctrl     *gomock.Controller
		recorder *MockLoanUsecaseMockRecorder
	}
	tests := []struct {
		name   string
		fields fields
		want   *MockLoanUsecaseMockRecorder
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &MockLoanUsecase{
				ctrl:     tt.fields.ctrl,
				recorder: tt.fields.recorder,
			}
			if got := m.EXPECT(); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecase.EXPECT() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecase_CreateLoan(t *testing.T) {
	type fields struct {
		ctrl     *gomock.Controller
		recorder *MockLoanUsecaseMockRecorder
	}
	type args struct {
		totalAmount       float64
		InstallmentAmount float64
		InstallmentType   string
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *models.Loan
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &MockLoanUsecase{
				ctrl:     tt.fields.ctrl,
				recorder: tt.fields.recorder,
			}
			got, err := m.CreateLoan(tt.args.totalAmount, tt.args.InstallmentAmount, tt.args.InstallmentType)
			if (err != nil) != tt.wantErr {
				t.Errorf("MockLoanUsecase.CreateLoan() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecase.CreateLoan() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecaseMockRecorder_CreateLoan(t *testing.T) {
	type fields struct {
		mock *MockLoanUsecase
	}
	type args struct {
		totalAmount       interface{}
		InstallmentAmount interface{}
		InstallmentType   interface{}
	}
	tests := []struct {
		name   string
		fields fields
		args   args
		want   *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mr := &MockLoanUsecaseMockRecorder{
				mock: tt.fields.mock,
			}
			if got := mr.CreateLoan(tt.args.totalAmount, tt.args.InstallmentAmount, tt.args.InstallmentType); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecaseMockRecorder.CreateLoan() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecase_GetLoanByID(t *testing.T) {
	type fields struct {
		ctrl     *gomock.Controller
		recorder *MockLoanUsecaseMockRecorder
	}
	type args struct {
		loanID uint
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *models.Loan
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &MockLoanUsecase{
				ctrl:     tt.fields.ctrl,
				recorder: tt.fields.recorder,
			}
			got, err := m.GetLoanByID(tt.args.loanID)
			if (err != nil) != tt.wantErr {
				t.Errorf("MockLoanUsecase.GetLoanByID() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecase.GetLoanByID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecaseMockRecorder_GetLoanByID(t *testing.T) {
	type fields struct {
		mock *MockLoanUsecase
	}
	type args struct {
		loanID interface{}
	}
	tests := []struct {
		name   string
		fields fields
		args   args
		want   *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mr := &MockLoanUsecaseMockRecorder{
				mock: tt.fields.mock,
			}
			if got := mr.GetLoanByID(tt.args.loanID); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecaseMockRecorder.GetLoanByID() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestMockLoanUsecase_UpdateLoan(t *testing.T) {
	type fields struct {
		ctrl     *gomock.Controller
		recorder *MockLoanUsecaseMockRecorder
	}
	type args struct {
		loanID            uint
		totalAmount       float64
		InstallmentAmount float64
		InstallmentType   string
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			m := &MockLoanUsecase{
				ctrl:     tt.fields.ctrl,
				recorder: tt.fields.recorder,
			}
			if err := m.UpdateLoan(tt.args.loanID, tt.args.totalAmount, tt.args.InstallmentAmount, tt.args.InstallmentType); (err != nil) != tt.wantErr {
				t.Errorf("MockLoanUsecase.UpdateLoan() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func TestMockLoanUsecaseMockRecorder_UpdateLoan(t *testing.T) {
	type fields struct {
		mock *MockLoanUsecase
	}
	type args struct {
		loanID            interface{}
		totalAmount       interface{}
		InstallmentAmount interface{}
		InstallmentType   interface{}
	}
	tests := []struct {
		name   string
		fields fields
		args   args
		want   *gomock.Call
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mr := &MockLoanUsecaseMockRecorder{
				mock: tt.fields.mock,
			}
			if got := mr.UpdateLoan(tt.args.loanID, tt.args.totalAmount, tt.args.InstallmentAmount, tt.args.InstallmentType); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("MockLoanUsecaseMockRecorder.UpdateLoan() = %v, want %v", got, tt.want)
			}
		})
	}
}
